<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="style.css">
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
 <link rel="stylesheet" href="//code.jquery.com/ui/1.11.2/themes/smoothness/jquery-ui.css">
  <script src="//code.jquery.com/jquery-1.10.2.js"></script>
  <script src="//code.jquery.com/ui/1.11.2/jquery-ui.js"></script>


<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/lodash.js/0.10.0/lodash.min.js"></script>

<script src="chord.js"></script>
</head>
<body>
<div class="container-fluid">
	<div class="page-header">
		<h1> InfoViz - Personal Project </h1>
		<h2> Yi-Yin Wang </h2>
		<p>Built with <a href="http://d3js.org/">d3.js</a>.</aside>
	</div>
	<div class="row">
		<div class="panel panel-default col-md-3">
			<div class="panel-heading">Filter</div>
		  	<div class="panel-body">
		  		<select class="form-control">
				  <option>Flights</option>
				  <option>Passengers</option>				
				</select>
		   		
		   		<!-- State Filter -->
		   		
		   		<div>
		   			<b> <label for"amount">State Population Rank: </label>
		   			<input type="text" id="amount" readonly style="border:0;">
		   			</b>
		   			<div id="slider-range"></div>
		   		</div>
		   		 <button id="submit" class="btn btn-default">Submit</button>
		   		
		   		<div class="radio">
				  <label>
				    <input type="radio" name="optionsRadios" id="optionsRadios1" value="state_all" checked>
				    All
				  </label>
				</div>
				<div class="radio">
				  <label>
				    <input type="radio" name="optionsRadios" id="optionsRadios2" value="state_large">
				    Large
				  </label>
				</div>
				<div class="radio">
				  <label>
				    <input type="radio" name="optionsRadios" id="optionsRadios3" value="state_median">
				    Median
				  </label>
				</div>
				<div class="radio">
				  <label>
				    <input type="radio" name="optionsRadios" id="optionsRadios4" value="state_median">
				    Small
				  </label>
				</div>
		  	</div>
		 
		</div>
		<div id="chordDiv" class="col-md-9"></div>
	</div>
</div> <!--End of container -->
<script type="text/javascript">



var state_ip = ['1', '2', '4', '5', '6', '8', '9', '10', '12', '13', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '44', '45', '46', '47', '48', '49', '50', '51', '53', '54', '55', '56']; //50 states 

var state_pop_rank = ["6","48","36","12","17","42","39","26","13","37","34","51","53","25","18","4","47","29","24","55","27","8","1","45","22","21","41","40","9","19","28","5","20","49","32","35","54","31","16","15","23","33","44","30","10","46","2","38","50","56"]

var state_info = {};
var ip_stateName = {"1":"Alabama",
					"2":"Alaska",
					"4":"Arizona",
					"5":"Arkansas",
					"6":"California",
					"8":"Colorado",
					"9":"Connecticut",
					"10":"Delaware",
					"12":"Florida",
					"13":"Georgia",
					"15":"Hawaii",
					"16":"Idaho",
					"17":"Illinois",
					"18":"Indiana",
					"19":"Iowa",
					"20":"Kansas",
					"21":"Kentucky",
					"22":"Louisiana",
					"23":"Maine",
					"24":"Maryland",
					"25":"Massachusetts",
					"26":"Michigan",
					"27":"Minnesota",
					"28":"Mississippi",
					"29":"Missouri",
					"30":"Montana",
					"31":"Nebraska",
					"32":"Nevada",
					"33":"New Hampshire",
					"34":"New Jersey",
					"35":"New Mexico",
					"36":"New York",
					"37":"North Carolina",
					"38":"North Dakota",
					"39":"Ohio",
					"40":"Oklahoma",
					"41":"Oregon",
					"42":"Pennsylvania",
					"44":"Rhode Island",
					"45":"South Carolina",
					"46":"South Dakota",
					"47":"Tennessee",
					"48":"Texas",
					"49":"Utah",
					"50":"Vermont",
					"51":"Virginia",
					"53":"Washington",
					"54":"West Virginia",
					"55":"Wisconsin",
					"56":"Wyoming"}

var last_chord; //save the existing layout for transition effect

function drawChr(matrix,states,chosenStatesOrder){
	console.log(matrix);
	
	/** Create the chord layout object **/

	var chord = d3.layout.chord()  
    	.padding(.05)
    	.sortSubgroups(d3.descending)		// TODO: Change sorting
    	.matrix(matrix);  //set the input data

	/** Define parameters and tools **/
	var width = 860, //960,
	    height = 840,//500,
	    innerRadius = Math.min(width, height) * .35,
	    outerRadius = innerRadius * 1.1;

	//TODO: scale for passener different from scale for flight
	var fill2 = d3.scale.ordinal()
	    .domain(d3.range(4)) 													
	    .range(["#000000", "#FFDD89", "#957244", "#F26223"]);  					//TODO: color choice

	var fillState = d3.scale.ordinal()
	    .domain(d3.range(4)) 													
	    .range(["#FFC061", "#F15854", "#42C250", "#A4E5F5"]);  

	var arc = d3.svg.arc()
				.innerRadius(innerRadius)
				.outerRadius(outerRadius);

	var path =d3.svg.chord()
				.radius(innerRadius);

	/** Draw the circle **/
	var svg = d3.select("#chordDiv").append("svg")
	    .attr("width", width)
	    .attr("height", height)
	  	.append("g")
	    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
	    .attr("id", "circle");

	    // Make room for state name
	    svg.append("circle")
                .attr("r", innerRadius +250);
	

 	

	/*******************
	/** Groups
	/** d(arc): index,startAngle, endAngel,value
	/*******************
	/* Add a group per neighborhood.*/
	
	
	var group = svg.selectAll(".group")
		.data(chord.groups)
		.enter().append("g")
		.attr("class", "group")
		.on("mouseover", fade(.1))
	    .on("mouseout", fade(1))
		.on("mouseover", mouseover);
	
	
	/*TODO: Change group*/
	/*************************************************
	/* Attemp to use transition after filter : Label
	**************************************************
		var group = svg.selectAll("g.group")
			.data(chord.groups(), function (d){
				console.log(d);
				return d.index;
			})


			group.exit()
				 .transition()
				 .duration(1500)
	        	.attr("opacity", 0)
	        	.remove();//remove after transitions are complete
	        	
	    var newGroup = group.enter().append("g")
	    				.attr("class", "group");

	   

		//create new arc path
		newGroup.append("path")
				.attr("id", function(d, i) { return "group" + d.index; })
				.style("fill", function(d) { return fill(d.index); }) 



		//update the arc paths to match the layout
		
		group.select("path")
			.transition()
	        .duration(1500)
	         .attrTween("d", arcTween(last_chord))

	    // add mouseover effect
	    group.on("mouseover", mouseover);

		*/


	/* Draw a group arc */
	
	var groupPath = group.append("path")
	 				.attr("id", function(d, i) { return "group" + i; })
					.attr("d", arc)
					.style("fill", function(d,i) { return fillState(+states[i].region); }) //TODO: change arc color
	    			.style("stroke", function(d,i) { return fillState(+states[i].region); })				
	
	/* Add text label on group */

	//For debug use
	var groupText = group.append("text")
					.attr("x", 6)
					.attr("dy", 15);
					 
					groupText.append("textPath")
					.attr("xlink:href", function(d, i) { return "#group" + i; })
					.text(function(d, i) { console.log(d);return (ip_stateName[chosenStatesOrder[i]]); });

	
	// Add text outside the circle
	
	var gTxt = group.append("svg:text")
					.each(function(d) { d.angle = (d.startAngle + d.endAngle) / 2; })
		            .attr("dy", ".35em")
		            .style("font-family", "arial, sans-serif")
		            .style("font-size", "10px")
		            .style("font-family", "arial, sans-serif")
		            .attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
		            .attr("transform", function(d) {
		              return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
		                  + "translate(" + (innerRadius + 50) + ")"
		                  + (d.angle > Math.PI ? "rotate(180)" : "");
		            })
		            .text(function(d,i){ return ip_stateName[chosenStatesOrder[i]]; });
	
		            console.log((state_ip[0]));
		            
		            //console.log(states[state_ip[0]]);
					console.log(states);



	/*************************************************
	/* Attemp to use transition after filter : Label
	**************************************************

		newGroup.append("svg:text")
				.attr("dy", ".35em")
				.style("font-family", "arial, sans-serif")
			    .style("font-size", "10px")
			    .style("font-family", "arial, sans-serif")
			    .text(function(d,i){ return ip_stateName[chosenStatesOrder[i]]; });


	    group.select("text")
	    	.transition()
	        .duration(1500)
	        .attr("transform", function(d) {
			             d.angle = (d.startAngle + d.endAngle) / 2;
	       				 //store the midpoint angle in the data object

				        return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" +
				            " translate(" + (innerRadius + 26) + ")" + (d.angle > Math.PI ? " rotate(180)" : " rotate(0)");
	        //include the rotate zero so that transforms can be interpolated
	    })
		            
        .attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
	*/

	function mouseover(d, i) {
		//TODO: more mouseover effect : 1. tooltip, 2.arc fade


		insideChord.classed("fadechord", function(p) {
			return p.source.index != i
				&& p.target.index != i;
		});
	}


	/*******************
	  TODO:Ticks granuality
	*******************/

	var ticks = svg.append("g").selectAll("g")
	    .data(chord.groups)
	  .enter().append("g").selectAll("g")
	    .data(groupTicks)
	  .enter().append("g")
	    .attr("transform", function(d) {
	      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
	          + "translate(" + outerRadius + ",0)";
	    });

	ticks.append("line")
	    .attr("x1", 1)
	    .attr("y1", 0)
	    .attr("x2", 5)
	    .attr("y2", 0)
	    .style("stroke", "#000");

	ticks.append("text")
	    .attr("x", 8)
	    .attr("dy", ".35em")
	    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
	    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
	    .text(function(d) { return d.label; }); //TODO: change label


	/*******************
	  Chord
	  d(group) : source, target
	*******************/
	
	var insideChord = svg.selectAll(".chord")
						.data(chord.chords)
						.enter().append("path")
						.attr("class", "chord")
						.style("fill", function(d,i) { console.log(d);return fillState(+states[d.source.index].region); }) //TODO
						.style("stroke", function(d,i) { console.log(d);return fillState(+states[d.source.index].region); }) //TODO
						.attr("d",path);
	
	
	
	/**********************************************************
	/* Attemp to use transition after filter : Update chord
	*********************************************************
		var insideChord = svg.selectAll("path.chord")
							.data(chord.chords(),chordKey); 
							// chordkey://specify a key function to match chords
	    //between updates

		//create new chord paths
		var newChordPath = insideChord.enter()
							.append("path")
							.attr("class", "chord")
							
		//Update exiting paths:
	    insideChord.exit().transition()
	        .duration(1500)
	        .attr("opacity", 0)
	        .remove();

		//update the path shape
		insideChord.transition()
			     .duration(1500)
			     .style("fill", function(d) { return fill(d.target.index); }) //TODO
			     .attrTween("d", chordTween(last_chord))


		*/



	// TODO: Add an elaborate mouseover title for each chord.
	
	 insideChord.append("title").text(function(d) {
	 	return d.target.value;
	 });
	

	// Returns an array of tick angles and labels, given a group.
	//TODO: change tick 
	function groupTicks(d) {
	  var k = (d.endAngle - d.startAngle) / d.value;
	  return d3.range(0, d.value, 1000).map(function(v, i) {
	    return {
	      angle: v * k + d.startAngle,
	      label: i % 5 ? null : v / 1000 +"k"
	    };
	  });
	}

	// Returns an event handler for fading a given chord group.
	function fade(opacity) {
	  return function(g, i) {
	    svg.selectAll(".chord path")
	        .filter(function(d) { return d.source.index != i && d.target.index != i; })
	      .transition()
	        .style("opacity", opacity);
	  };
	}

	last_chord = chord; //save current layout

} // End of drawChr


/** Attempt to use transition forr fillter data **/
function arcTween(oldChord) {

	var oldGroups = {};
	if (oldChord){
		console.log("yes");
		oldChord.groups().forEach(function (groupData) {
            oldGroups[groupData.index] = groupData;
        });
    }
	return function (d, i) {
        var tween;
        var old = oldGroups[d.index];
        if (old) { //there's a matching old group
            tween = d3.interpolate(old, d);
        } else {
            //create a zero-width arc object
            var emptyArc = {
                startAngle: d.startAngle,
                endAngle: d.startAngle
            };
            tween = d3.interpolate(emptyArc, d);
        }

        return function (t) {
            return arc(tween(t));
        };
    };
}

function chordKey(data) {
    return (data.source.index < data.target.index) ? data.source.index + "-" + data.target.index : data.target.index + "-" + data.source.index;

    //create a key that will represent the relationship
    //between these two groups *regardless*
    //of which group is called 'source' and which 'target'
}

function chordTween(oldLayout) {
  var oldChords = {};

    if (oldLayout) {
        oldLayout.chords().forEach(function (chordData) {
            oldChords[chordKey(chordData)] = chordData;
        });
    }

    return function (d, i) {
        //this function will be called for each active chord

        var tween;
        var old = oldChords[chordKey(d)];
        if (old) {
            //old is not undefined, i.e.
            //there is a matching old chord value

            //check whether source and target have been switched:
            if (d.source.index != old.source.index) {
                //swap source and target to match the new data
                old = {
                    source: old.target,
                    target: old.source
                };
            }

            tween = d3.interpolate(old, d);
        } else {
            //create a zero-width chord object
            if (oldLayout) {
                var oldGroups = oldLayout.groups().filter(function (group) {
                    return ((group.index == d.source.index) || (group.index == d.target.index))
                });
                old = {
                    source: oldGroups[0],
                    target: oldGroups[1] || oldGroups[0]
                };
                //the OR in target is in case source and target are equal
                //in the data, in which case only one group will pass the
                //filter function

                if (d.source.index != old.source.index) {
                    //swap source and target to match the new data
                    old = {
                        source: old.target,
                        target: old.source
                    };
                }
            } else old = d;

            var emptyChord = {
                source: {
                    startAngle: old.source.startAngle,
                    endAngle: old.source.startAngle
                },
                target: {
                    startAngle: old.target.startAngle,
                    endAngle: old.target.startAngle
                }
            };
            tween = d3.interpolate(emptyChord, d);
        }

        return function (t) {
            //this function calculates the intermediary shapes
            return path(tween(t));
        };
    };
}



function makechord(popMin,popMax){
	//popMin = typeof(popMin) !== 'undefined' ? popMin : 563626;
	//popMax = typeof(popMax) !== 'undefined' ? popMax : 37253956;

	popMin = typeof(popMin) !== 'undefined' ? popMin : 0;
	popMin = typeof(popMin) !== 'undefined' ? popMin : 50;

	console.log(popMin);
	console.log(popMax);
	/*
		var threshold = 0;
		switch(state_option){
			case "all":break;
			case "state_large":
				threshold = 6000000;
				break;
			case "state_median":
				threshold = 1200000;
				break;
			case "state_small":
				threshold = 50000;
			default:
				break;
		}
	*/

	var flights = [];
	d3.csv("data/states.csv",function(states){
	
	//d3.json('data/flight.json', function (error, data) {
	d3.json('data/data.json', function (error, data) {		
		console.log(data);
		var chosenStates = state_pop_rank.slice(popMin,popMax)
		var chosenStatesOrder =[];
		$.each(states,function(index,obj){			
			var ip = obj.state_fip;
			if (chosenStates.indexOf(ip)>-1){ // check if ip exist in chosenStates
				var origState = Array.apply(null,new Array(52)).map(Number.prototype.valueOf,0);

				$.each(states, function(idx,obj){
					var ip2 = obj.state_fip;
					if (ip2 in data[ip]){
						if (ip2 in data){
							origState[idx] = data[ip][ip2].flight;
						
						}
					}
				})

				flights.push(origState);
				chosenStatesOrder.push(ip);

			}
		})
	
	console.log(flights);
	drawChr(flights,states,chosenStatesOrder);
 
    }) //end of Flight data
	
	})//end of csv
} // End of makechord func


/* Listen to filter */
$(document).ready(function () { 

	d3.json("data/stateInfo.json",function(error,json){
		state_info = json;
	})

	makechord();

	//population slider
	$(function() {
	    $( "#slider-range" ).slider({
	      range: true,
	      min:1,
	      max: 50,
	      values: [0,50],
	      slide: function( event, ui ) {
	        $( "#amount" ).val(  "Rank "+ ui.values[ 0 ] + " - " +  "Rank "+ ui.values[ 1 ] );
	      }
	    });
	    $( "#amount" ).val( "Rank "+  $( "#slider-range" ).slider( "values", 0 ) + " - "
	       + "Rank "+ $( "#slider-range" ).slider( "values", 1 ) );    
  	});

	popMap = d3.scale.sqrt()
				.domain([0,100])
      			.range([563626,37253956]);
      
	$("#submit").click(function(event){
		var popRankMin = ($( "#slider-range" ).slider( "values", 0 ) -1);
		var popRankMax = ($( "#slider-range" ).slider( "values", 1 ));
		$("#chordDiv").empty();

		makechord(popRankMin,popRankMax);
	})


});

	/*******************************************************************
      //  DRAW THE CHORD DIAGRAM
      //*******************************************************************/
      function drawChords (matrix, mmap) {
        var w = 980, h = 800, r1 = h / 2, r0 = r1 - 100;

        var fill = d3.scale.ordinal()
            .range(['#c7b570','#c6cdc7','#335c64','#768935','#507282','#5c4a56','#aa7455','#574109','#837722','#73342d','#0a5564','#9c8f57','#7895a4','#4a5456','#b0a690','#0a3542',]);

        var chord = d3.layout.chord()
            .padding(.02)
            .sortSubgroups(d3.descending)

        var arc = d3.svg.arc()
            .innerRadius(r0)
            .outerRadius(r0 + 20);

        var svg = d3.select("body").append("svg:svg")
            .attr("width", w)
            .attr("height", h)
          .append("svg:g")
            .attr("id", "circle")
            .attr("transform", "translate(" + w / 2 + "," + h / 2 + ")");

            svg.append("circle")
                .attr("r", r0 + 20);

        var rdr = chordRdr(matrix, mmap);
        chord.matrix(matrix);

        var g = svg.selectAll("g.group")
            .data(chord.groups())
          .enter().append("svg:g")
            .attr("class", "group")
            .on("mouseover", mouseover)
            .on("mouseout", function (d) { d3.select("#tooltip").style("visibility", "hidden") });

        g.append("svg:path")
            .style("stroke", "black")
            .style("fill", function(d) { return rdr(d).gdata == "state" ? "black": "grey"; })
            .attr("d", arc);

        g.append("svg:text")
            .each(function(d) { d.angle = (d.startAngle + d.endAngle) / 2; })
            .attr("dy", ".35em")
            .style("font-family", "helvetica, arial, sans-serif")
            .style("font-size", "10px")
            .attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
            .attr("transform", function(d) {
              return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
                  + "translate(" + (r0 + 26) + ")"
                  + (d.angle > Math.PI ? "rotate(180)" : "");
            })
            .text(function(d) { return rdr(d).gname; });

          var chordPaths = svg.selectAll("path.chord")
                .data(chord.chords())
              .enter().append("svg:path")
                .attr("class", "chord")
                .style("stroke", "black")
                .style("fill", function(d) { return rdr(d).tname == "Starbucks" ? "#00592d": "#ff6200"; })
                .attr("d", d3.svg.chord().radius(r0))
                .on("mouseover", function (d) {
                  d3.select("#tooltip")
                    .style("visibility", "visible")
                    .html(chordTip(rdr(d)))
                    .style("top", function () { return (d3.event.pageY - 170)+"px"})
                    .style("left", function () { return (d3.event.pageX - 100)+"px";})
                })
                .on("mouseout", function (d) { d3.select("#tooltip").style("visibility", "hidden") });

          function chordTip (d) {
            var p = d3.format(".1%"), q = d3.format(",f")
            return "Chord Info:<br/>"
              +  d.sname + " → " + d.tname
              + ": " + q(d.svalue) + "<br/>"
              + p(d.svalue/d.stotal) + " of " + d.sname + "'s Total (" + q(d.stotal) + ")<br/>"
              + p(d.svalue/(d.mtotal/2)) + " of Matrix Total (" + q(d.mtotal/2) + ")<br/>"
              + "<br/>"
              + d.tname + " → " + d.sname
              + ": " + q(d.tvalue) + "<br/>"
              + p(d.tvalue/d.ttotal) + " of " + d.tname + "'s Total (" + q(d.ttotal) + ")<br/>"
              + p(d.tvalue/(d.mtotal/2)) + " of Matrix Total (" + q(d.mtotal/2) + ")";
          }

          function groupTip (d) {
            var p = d3.format(".1%"), q = d3.format(",f")
            return "Group Info:<br/>"
                + d.gname + " : " + q(d.gvalue) + "<br/>"
                + p(d.gvalue/(d.mtotal/2)) + " of Matrix Total (" + q(d.mtotal/2) + ")"
          }

          function mouseover(d, i) {

            d3.select("#tooltip")
              .style("visibility", "visible")
              .html(groupTip(rdr(d)))
              .style("top", function () { return (d3.event.pageY - 80)+"px"})
              .style("left", function () { return (d3.event.pageX - 130)+"px";})

            chordPaths.classed("fade", function(p) {
              return p.source.index != i
                  && p.target.index != i;
            });
          }
        }
</script>

<body>
</html>